{% extends "base.html" %}

{% block content %}
    <div class="row">
        <p><a href="javascript:history.back(1)" class="btn btn-primary">‚Üê Back</a></p>

        <h2 class="text-center">From 
            {% if url %}
                <a href="{{ url }}" target="_blank">{{ title }}</a>
            {% else %}
                {{ title }}
            {% endif %}
        </h2>
        <p class="text-center">

            <b>{{ date }} | 
                {% if coverage %}
                    <a href="{{ coverage }}" target="_blank">{{ place }}</a>
                {% else %}
                    {{ place }}
                {% endif %}
            </b>
        </p>    
        {% if open == "true" and (not corpus.startswith('ia') and not corpus.startswith('ca') and not corpus.startswith('acdc')) %}
        <div class="col-md-6">
          <p>acdc</p>
                {% for paragraph in paragraphs %}
                    {% set highlighted_paragraph = paragraph|replace(search_term, '<strong>' + search_term + '</strong>')|safe %}
                <p>{{ highlighted_paragraph }}</p>
                {% endfor %}
            </div>

            {% if images is not none %}
                <div class="col-md-6">
                    <img src="{{ images }}" alt="Thumbnail" onerror="this.style.display='none';" class="img-fluid ">
                </div>
            {% endif %}

        {% elif open == "false" %}
            <div class="col-md-12">
                <p>This text comes from a proprietary database and is unavailable due to copyright restrictions.</p>
            </div>
        
            <div class="col-md-12">
                {% if url is not none %}
                    <p><a href="{{ url }}" target="_blank">{{ url }}</a></p>
                {% endif %}
            </div>
        
        {% elif corpus.startswith('ia') %}
  <div id="ia-mirador"></div>

{% elif corpus.startswith('ca') or corpus.startswith('acdc'):
 %}
  <div id="ca-mirador"></div>

{% endif %}

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", async function () {
  // server-passed bits
  const corpus = "{{ corpus }}";
  const rawCanvasIndex = {{ canvas_index if canvas_index is not none else 0 }};
  const canvasIndex = Math.max(0, (rawCanvasIndex || 0));

  const isCA = typeof corpus === "string" && (corpus.startsWith("ca") || corpus.startsWith("acdc"));
  const viewerId = isCA ? "ca-mirador" : (corpus === "ia" ? "ia-mirador" : null);

  if (!viewerId) return;

  const mountEl = document.getElementById(viewerId);
  if (!mountEl) {
    console.error("Missing viewer container:", viewerId, "corpus:", corpus);
    return;
  }

  // build manifest URL per corpus
  const iaManifestUrl = `https://iiif.archive.org/iiif/3/{{ manifest_id }}/manifest.json`;

  // LOC (Chronicling America) and acdc. might need others.
  const locManifestRaw = `{{ loc_manifest_url or '' }}`;
  const locManifestUrl = locManifestRaw
    ? `/loc-proxy?url=${encodeURIComponent(locManifestRaw)}`
    : null;

  const manifestUrl = corpus === "ia" ? iaManifestUrl : locManifestUrl;
  if (!manifestUrl) return;

  // filter out supplemental image annotations (should get rid of ocr-ish layers)
  const noSupplementing = (annotation) => annotation.motivation !== 'supplementing';

  const ReprintsTranslationPlugin = {
    id: 'reprints-translation',
    config: {
      translations: {
        en: {
          annotations: 'Explore reprints on this page'
        }
      }
    }
  };

  function setupMirador(manifestId, viewerId, itemCanvasIndex) {
    const instance = Mirador.viewer({
      id: viewerId,
      windows: [{ manifestId, canvasIndex: itemCanvasIndex, view: 'single' }],
      window: {
        defaultView: 'single',
        highlightAllAnnotations: false,
        forceDrawAnnotations: true,
        defaultSideBarPanel: 'annotations',
        sideBarOpen: true,
        canvasAnnotations: true,
        sideBarOpenByDefault: true,
      },
      workspaceControlPanel: { enabled: false },
      annotation: { filter: noSupplementing },
    }, [ReprintsTranslationPlugin]);

    return new Promise((resolve) => {
      const poll = () => {
        const ids = Object.keys(instance.store.getState()?.windows || {});
        if (ids.length) return resolve({ instance, windowId: ids[0] });
        setTimeout(poll, 100);
      };
      poll();
    });
  }

  try {
    // lc uses iiif v2, ia uses v3.
    const r = await fetch(manifestUrl);
    const manifest = await r.json();

    // try IIIF v3 first (items), else v2 (sequences[0].canvases)
    const canvases = Array.isArray(manifest?.items)
      ? manifest.items
      : (manifest?.sequences?.[0]?.canvases || []);

    // map canvasId -> index so we can compute seq later
    const canvasIndexById = {};
    canvases.forEach((c, i) => {
      const cid = c.id || c['@id'];
      if (cid) canvasIndexById[cid] = i;
    });

    let effectiveIndex = canvasIndex;
    if (isCA) {
      // your existing off-by-one fix for LOC
      effectiveIndex = Math.max(0, canvasIndex - 1);
    }

    const page = canvases?.[effectiveIndex];
    if (!page) {
      console.warn("Canvas index out of range:", effectiveIndex, canvases.length);
      return;
    }

    // canvas dimensions
    const dims = (() => {
      if (page.width && page.height) return { width: page.width, height: page.height };
      const res = page.images?.[0]?.resource;
      return { width: (res?.width || 0), height: (res?.height || 0) };
    })();

    // üöÄ create Mirador now
    const { instance, windowId } = await setupMirador(manifestUrl, viewerId, effectiveIndex);

    // current canvasId once Mirador is up
    const state = instance.store.getState();
    let currentCanvasId =
      state.windows?.[windowId]?.canvasId || page.id || page['@id'];

    const clustersCsv = '';
    const docId = "{{ doc_id }}";

    // Helper to request annotations for a given canvasId
    function requestAnnotationsForCanvas(canvasId) {
      const idx = canvasIndexById[canvasId];
      if (idx == null) return;

      // If CA/acdc p1seq is 1-based, use (idx + 1) for those
      const seq = isCA ? (idx + 1) : idx;

      const annoUrl =
        `/annotations/${docId}.json` +
        `?canvasId=${encodeURIComponent(canvasId)}` +
        `&seq=${seq}` +
        (clustersCsv ? `&clusters=${clustersCsv}` : '');

      instance.store.dispatch(
        Mirador.actions.requestAnnotation(canvasId, annoUrl)
      );
    }

    // Initial load (after a short delay so Mirador is ready)
    setTimeout(() => {
      requestAnnotationsForCanvas(currentCanvasId);
    }, 400);

    // Subscribe to page changes (next/previous)
    let lastCanvasId = currentCanvasId;
    instance.store.subscribe(() => {
      const state = instance.store.getState();
      const win = state.windows?.[windowId];
      if (!win) return;

      const newCanvasId = win.canvasId;
      if (newCanvasId && newCanvasId !== lastCanvasId) {
        lastCanvasId = newCanvasId;
        requestAnnotationsForCanvas(newCanvasId);
      }
    });

    // zoom on images
    const m = ("{{ images or '' }}".match(/\/pct:([\d.]+),([\d.]+),([\d.]+),([\d.]+)\//) || []);
    if (m.length === 5 && dims.width && dims.height) {
      const pct = { x:+m[1], y:+m[2], w:+m[3], h:+m[4] };
      const px  = {
        x: (pct.x/100)*dims.width,
        y: (pct.y/100)*dims.height,
        w: (pct.w/100)*dims.width,
        h: (pct.h/100)*dims.height,
      };
      const center = { x: px.x + px.w/2, y: px.y + px.h/2 };
      const action = Mirador.actions.updateViewport(windowId, {
        x: center.x, y: center.y, zoom: 0.5/px.w
      });
      setTimeout(() => instance.store.dispatch(action), 600);
    }
  } catch (e) {
    console.error('[M3] Mirador error:', e);
  }
});
</script>



<style>
  /* debug this not sure if it works */
  [data-annotation-id] rect {
  stroke: rgba(255,0,0,0.9) !important;
  stroke-width: 3 !important;
  fill: rgba(255,0,0,0.10) !important;
}
</style>


    </div>
{% endblock %}



