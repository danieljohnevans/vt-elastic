{% extends "base.html" %}

{% block content %}
    <div class="row">
        <p><a href="javascript:history.back(1)" class="btn btn-primary">‚Üê Back</a></p>

        <h2 class="text-center">From 
            {% if url %}
                <a href="{{ url }}" target="_blank">{{ title }}</a>
            {% else %}
                {{ title }}
            {% endif %}
        </h2>
        <p class="text-center">

            <b>{{ date }} | 
                {% if coverage %}
                    <a href="{{ coverage }}" target="_blank">{{ place }}</a>
                {% else %}
                    {{ place }}
                {% endif %}
            </b>
        </p>    
        {% if open == "true" and (not corpus.startswith('ia') and not corpus.startswith(('ca', 'acdc'))) %}
        <div class="col-md-6">
                {% for paragraph in paragraphs %}
                    {% set highlighted_paragraph = paragraph|replace(search_term, '<strong>' + search_term + '</strong>')|safe %}
                <p>{{ highlighted_paragraph }}</p>
                {% endfor %}
            </div>

            {% if images is not none %}
                <div class="col-md-6">
                    <img src="{{ images }}" alt="Thumbnail" onerror="this.style.display='none';" class="img-fluid ">
                </div>
            {% endif %}

        {% elif open == "false" %}
            <div class="col-md-12">
                <p>This text comes from a proprietary database and is unavailable due to copyright restrictions.</p>
            </div>
        
            <div class="col-md-12">
                {% if url is not none %}
                    <p><a href="{{ url }}" target="_blank">{{ url }}</a></p>
                {% endif %}
            </div>
        
        {% elif corpus.startswith('ia') %}
  <div id="ia-mirador"></div>

{% elif corpus.startswith(('ca', 'acdc')) %}
  <div id="ca-mirador"></div>

{% endif %}

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", async function () {
  // server-passed bits
  const corpus = "{{ corpus }}";
  const rawCanvasIndex = {{ canvas_index if canvas_index is not none else 0 }};
  // Your ES "p1seq" is effectively 0-based, but we still guard here:
  const canvasIndex = Math.max(0, (rawCanvasIndex || 0));

  // Choose manifest and viewer holder
  const viewerId =
  corpus && corpus.startsWith(("ca", "acdc")) ? "ca-mirador" :
  corpus === "ia" ? "ia-mirador" : null;

if (!viewerId) return;

const mountEl = document.getElementById(viewerId);
if (!mountEl) {
  console.error("Missing viewer container:", viewerId, "corpus:", corpus);
  return;
}

  // build manifest URL per corpus
  const iaManifestUrl = `https://iiif.archive.org/iiif/3/{{ manifest_id }}/manifest.json`;

  // LOC (Chronicling America) and acdc. might need others.
  const locManifestRaw = `{{ loc_manifest_url or '' }}`;
  const locManifestUrl = locManifestRaw
    ? `/loc-proxy?url=${encodeURIComponent(locManifestRaw)}`
    : null;

  const manifestUrl = corpus === "ia" ? iaManifestUrl : locManifestUrl;
  if (!manifestUrl) return;

  // filter out supplemental image annotations (should get rid of ocr)
  const noSupplementing = (annotation) => annotation.motivation !== 'supplementing';

  


  function setupMirador(manifestId, viewerId, itemCanvasIndex) {
    const instance = Mirador.viewer({
      id: viewerId,
      windows: [{ manifestId, canvasIndex: itemCanvasIndex, view: 'single' }],
      window: {
        defaultView: 'single',
        highlightAllAnnotations: false,
        forceDrawAnnotations: true,
        defaultSideBarPanel: 'annotations',
        sideBarOpen: true,
        canvasAnnotations: true,
        sideBarOpenByDefault: true,
      },
      workspaceControlPanel: { enabled: false },
      annotation: { filter: noSupplementing },
    });

    return new Promise((resolve) => {
      const poll = () => {
        const ids = Object.keys(instance.store.getState()?.windows || {});
        if (ids.length) return resolve({ instance, windowId: ids[0] });
        setTimeout(poll, 100);
      };
      poll();
    });
  }

  try {
    // lc uses iiif v2, ia uses v3. 
    const r = await fetch(manifestUrl);
    const manifest = await r.json();

    // try IIIF v3 first (items), else v2 (sequences[0].canvases)
    const canvases = Array.isArray(manifest?.items)
      ? manifest.items
      : (manifest?.sequences?.[0]?.canvases || []);

    let effectiveIndex = canvasIndex;
if (corpus.startsWith(("ca", "acdc"))) {
  effectiveIndex = Math.max(0, canvasIndex - 1);
}

const page = canvases?.[effectiveIndex];
if (!page) {
  console.warn("Canvas index out of range:", effectiveIndex, canvases.length);
  return;
}

    // canvas dimensions
const dims = (() => {
  if (page.width && page.height) return { width: page.width, height: page.height };
  const res = page.images?.[0]?.resource;
  return { width: res?.width || 0, height: res?.height || 0 };
})();
    const { instance, windowId } = await setupMirador(manifestUrl, viewerId, effectiveIndex);

    const state = instance.store.getState();
    const currentCanvasId =
      state.windows?.[windowId]?.canvasId || page.id || page['@id'];

    const clustersCsv = ''; 
    const annoUrl = `/annotations/{{ doc_id }}.json?canvasId=${encodeURIComponent(currentCanvasId)}${clustersCsv ? `&clusters=${clustersCsv}` : ''}`;

    // timeout bc mirador needs time to get setup before annotations can load
    setTimeout(() => {
      instance.store.dispatch(Mirador.actions.requestAnnotation(currentCanvasId, annoUrl));
    }, 400);

    // zoom on images
    const m = ("{{ images or '' }}".match(/\/pct:([\d.]+),([\d.]+),([\d.]+),([\d.]+)\//) || []);
    if (m.length === 5 && dims.width && dims.height) {
      const pct = { x:+m[1], y:+m[2], w:+m[3], h:+m[4] };
      const px  = {
        x: (pct.x/100)*dims.width,
        y: (pct.y/100)*dims.height,
        w: (pct.w/100)*dims.width,
        h: (pct.h/100)*dims.height,
      };
      const center = { x: px.x + px.w/2, y: px.y + px.h/2 };
      const action = Mirador.actions.updateViewport(windowId, {
        x: center.x, y: center.y, zoom: 0.5/px.w
      });
      setTimeout(() => instance.store.dispatch(action), 600);
    }
  } catch (e) {
    console.error('[M3] Mirador error:', e);
  }
});
</script>


<style>
  /* debug this not sure if it works */
  [data-annotation-id] rect {
  stroke: rgba(255,0,0,0.9) !important;
  stroke-width: 3 !important;
  fill: rgba(255,0,0,0.10) !important;
}
</style>


    </div>
{% endblock %}



